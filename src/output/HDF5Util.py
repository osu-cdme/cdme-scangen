# This is a utility to allow the creation of HDF5 type files from scanpath data generated by the pyslm based slicer.

import numpy as np
import h5py
import xml.etree.ElementTree as ET
import math
import os
from tqdm import tqdm # progress bar

# Various opportunities for performance improvement, if we end up needing to use them 
# TODO: Profiling with something like cProfile and snakeviz will probably be very insightful regarding which parts in here are gobbling up all the processing time 
# TODO: Can probably make XPath searches quicker by being more specific than "search the entire tree for anything with this tag" which probably involves a full linear search each time
# TODO: Can probably boost performance by caching/memoizing many of the segment style / velocity profile lookups, or keeping those in a set for O(1) lookups or something

# One instance of this class creates one instance of 
class HDF5Util: 

    def __init__(self, inputDir: str, outputName:str):
        self.inputDir = inputDir
        self.outputName = outputName
        self.file=h5py.File(outputName,'w')
        
    # Converts a directory containing the unzipped layer files (.xml suffix) into an HDF5 file. directory must NOT have any other files in it
    def convertSCNtoHDF5(self):
        numLayers = len(os.listdir(self.inputDir + '/'))

        import sys 
        for i in tqdm(range(numLayers), desc='XML -> HDF5', unit="layers", file=sys.stdout, smoothing=0):
            self.HDF5Layer(self.inputDir + '/scan_' + str(i + 1) + '.xml', self.file, i).exec()

    # Handles one file 
    class HDF5Layer:
        def __init__(self, xmlPath: str, hdf5_file: h5py.File, layerNum: int):
            self.xmlPath = xmlPath
            self.hdf5_file = hdf5_file
            self.layerTree = ET.parse(xmlPath)
            self.layerFolder = hdf5_file.create_group(str(layerNum)) # Create output object
            self.layerNum = layerNum

            # Store Segment Styles / Velocity Profiles as (id => attribute) maps, which lets us do O(1) lookups for corresponding segment styles and such
            self.cacheSegmentStyles()
            self.cacheVelocityProfiles()

        def cacheSegmentStyles(self):
            self.segmentStyles = {}
            for segmentStyle in self.layerTree.findall("./SegmentStyleList/SegmentStyle"):
                ID = segmentStyle.find('./ID').text
                self.segmentStyles[ID] = {}
                self.segmentStyles[ID]["velocityProfileID"] = segmentStyle.find('./VelocityProfileID').text
                travelers = segmentStyle.findall('./Travelers/Traveler')
                self.segmentStyles[ID]["power"] = float(travelers[0].find("./Power").text) if len(travelers) else 0 

        def cacheVelocityProfiles(self):
            self.velocityProfiles = {}
            for velocityProfile in self.layerTree.findall("./VelocityProfileList/VelocityProfile"):
                ID = velocityProfile.find('./ID').text
                self.velocityProfiles[ID] = {}
                self.velocityProfiles[ID]["velocity"] = float(velocityProfile.find('./Velocity').text)
                # TODO: Still need to account for things like JumpDelay, MarkDelay, PolygonDelay, etc 

        # Processes layer and adds corresponding layer to HDF5 file 
        def exec(self):
            self.layerFolder.create_dataset('/'+str(self.layerNum)+'/edgeData/power', data=self.generatePowerList(self.layerTree))
            self.layerFolder.create_dataset('/'+str(self.layerNum)+'/edgeData/velocity', data=self.generateVelocityList(self.layerTree))
            pointsList = self.generatePointList(self.layerTree)
            self.layerFolder.create_dataset('/'+str(self.layerNum)+'/points', data=pointsList)
            self.layerFolder.create_dataset('/'+str(self.layerNum)+'/edges',  data=self.generateEdges(pointsList))
            self.layerFolder.create_dataset('/'+str(self.layerNum)+'/pointData/time', data=self.generateTimeList(self.layerTree))

        #* Utility functions that occur frequently 
        def get_segment_style_of_segment(self, segment:str):
            return self.segmentStyles[segment.find('./SegStyle').text]

        def get_velocity_profile_of_segment(self,segment:str):
            return self.velocityProfiles[self.segmentStyles[segment.find('./SegStyle').text]["velocityProfileID"]]

        # generates an n by 1 numpy array listing the powers in order of each step in the print for the layer passed in
        def generatePowerList(self, layerTree:ET.ElementTree):
            trajectoryTree = layerTree.find('./TrajectoryList')
            if not trajectoryTree:
                raise ValueError('No TrajectoryList found in layerTree')
            
            segments = trajectoryTree.findall('./Trajectory/Path/Segment')
            powers = np.empty(len(segments), dtype=np.float64)
            for i in range(len(segments)):
                powers[i] = self.get_segment_style_of_segment(segments[i])["power"]

            return powers

        # generate an n by 1 numpy array listing the velocities in order of each step in the print for the layer passed in
        def generateVelocityList(self, layerTree:ET.ElementTree):
            trajectoryTree = layerTree.find('./TrajectoryList')
            segments = trajectoryTree.findall('./Trajectory/Path/Segment')
            velocities = np.empty(len(segments), dtype=np.float64)
            for i in range(len(segments)):
                velocities[i] = self.get_velocity_profile_of_segment(segments[i])["velocity"]
            return velocities

        # generates an n by 2 numpy array listing each vertex in order of the print for the layer passed in
        def generatePointList(self, layerTree:ET.ElementTree):
            trajectoryTree = layerTree.find('./TrajectoryList')

            paths = trajectoryTree.findall('./Trajectory/Path')
            segments = trajectoryTree.findall('./Trajectory/Path/Segment')

            # Paths add one point each, the start x/y, and segments add one point each, the end x/y
            # This lets us predetermine size of end array and avoid all uses of np.append
            points = np.empty((len(paths) + len(segments), 2), dtype=np.float64)
            i = 0

            # There is a separate start point for each path so the paths must be iterated through to pull it since its not labelled a segment
            # Not a convenient single loop here so we manually update the tqdm bar 
            for path in paths:

                startPoint = path.find('./Start')
                startX = float(startPoint.find('./X').text)
                startY = float(startPoint.find('./Y').text)
                points[i] = [startX,startY]
                i += 1

                for segment in path.findall('./Segment'):
                    x = float(segment.find('./End/X').text)
                    y = float(segment.find('./End/Y').text)
                    points[i] = [x,y]
                    i += 1

            return points

        # generates an n by 2 list of edges where the entries are the index of the start and end points in the pointList (NOTE:kinda redundant? the point list is ordered)
        def generateEdges(self, pointList:np.ndarray):
            if not len(pointList): 
                return np.array([])
            edgeList = np.empty((len(pointList) - 1, 2), dtype=np.int32)
            for i in range(len(pointList) - 1):
                edgeList[i] = [i, i + 1]
            return edgeList

        def generateTimeList(self, layerTree:ET.ElementTree):    
            trajectoryTree = layerTree.find('./TrajectoryList')

            timeList = np.empty(1 + len(trajectoryTree.findall('./Trajectory/Path/Segment')), dtype=np.float64)
            timeList[0] = 0;
            i = 1; 

            # There is a separate start point for each path so the paths must be iterated through to pull it since its not labelled as a segment
            # Not a convenient single loop here so we manually update the tqdm bar
            # TODO: Verify there isn't weird behavior from the last segment of a path to the first segment of another path
            paths = trajectoryTree.findall('./Trajectory/Path')
            for path in paths:
                startPoint = path.find('./Start')
                startX = float(startPoint.find('./X').text)
                startY = float(startPoint.find('./Y').text)

                for segment in path.findall('./Segment'):
                    endX = float(segment.find('./End/X').text)
                    endY = float(segment.find('./End/Y').text)

                    # this chunk finds the speed associated with the current end point
                    velocity = self.get_velocity_profile_of_segment(segment)["velocity"]
                    distance = math.sqrt(pow(endX-startX,2)+pow(endY-startY,2))
                    
                    time = distance/velocity
                    if time < 0: 
                        print("WARNING: Negative time detected. This is likely due to a negative velocity. Please check your velocity profile.")

                    timeList[i] = time
                    i += 1 

                    # need to update the start point for the distance on the next iteration through loop
                    startX = endX
                    startY = endY

            return timeList

        
        