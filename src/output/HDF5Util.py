# This is a utility to allow the creation of HDF5 type files from scanpath data generated by the pyslm based slicer.

import numpy as np
import h5py
import xml.etree.ElementTree as ET
import math
import os
from tqdm import tqdm # progress bar

# TODO: Profiling with something like cProfile and snakeviz will probably be very insightful regarding which parts in here are gobbling up all the processing time 
# TODO: Can probably make XPath searches quicker by being more specific than "search the entire tree for anything with this tag" which probably involves a full linear search each time
# TODO: Can probably boost performance by caching/memoizing many of the segment style / velocity profile lookups, or keeping those in a set for O(1) lookups or something

#* Utility functions that occur frequently 
def getSegmentStyleOfSegment(layerTree:ET.ElementTree, segment:str):
    id = segment.find('.//SegStyle').text
    for segmentStyle in layerTree.findall(".//SegmentStyle"):
        if segmentStyle.find('.//ID').text == id:
            return segmentStyle
    raise ValueError('SegmentStyleID {} not found in SegmentStyleList'.format(id))

def getVelocityProfileOfSegment(layerTree:ET.ElementTree, segment:str):
    segmentStyle = getSegmentStyleOfSegment(layerTree, segment)
    velocityProfileID = segmentStyle.find('.//VelocityProfileID').text
    for velocityProfile in layerTree.findall('.//VelocityProfile'):
        if velocityProfile.find('.//ID').text == velocityProfileID:
            return velocityProfile
    raise ValueError('VelocityProfileID {} not found in VelocityProfileList'.format(velocityProfileID))

# Adds a layer to an existing HDF5 file.
def addHDF5Layer(HDF5FileName:str,layer:h5py.File):
    top=h5py.File(HDF5FileName,'r+')
    thisLayer=top.create_group(layer.name)

# generates an n by 1 numpy array listing the powers in order of each step in the print for the layer passed in
def generatePowerList(layerTree:ET.ElementTree):
    trajectoryTree = layerTree.find('.//TrajectoryList')
    if not trajectoryTree:
        raise ValueError('No TrajectoryList found in layerTree')
    segmentStyleTree = layerTree.find('.//SegmentStyleList')
    if not segmentStyleTree:
        raise ValueError('No SegmentStyleList found in layerTree')
    
    segments = trajectoryTree.findall('.//Segment')
    powers = np.empty(len(segments), dtype=np.float64)
    def getPower(segment:ET.ElementTree):
        segmentStyle = getSegmentStyleOfSegment(layerTree, segment)
        if len(segmentStyle.findall('.//Traveler')):
            return int(segmentStyle.find('.//Power').text)
        return 0 # Jump
    for i in range(len(segments)):
        powers[i] = getPower(segments[i])

    return powers

# generate an n by 1 numpy array listing the velocities in order of each step in the print for the layer passed in
def generateVelocityList(layerTree:ET.ElementTree):
    trajectoryTree = layerTree.find('.//TrajectoryList')
    if not trajectoryTree:
        raise ValueError('No TrajectoryList found in layerTree')
    segmentStyleTree = layerTree.find('.//SegmentStyleList')
    if not segmentStyleTree:
        raise ValueError('No SegmentStyleList found in layerTree')
    VelocityProfileTree = layerTree.find('.//VelocityProfileList')
    if not VelocityProfileTree:
        raise ValueError('No VelocityProfileList found in layerTree')

    segments = trajectoryTree.findall('.//Segment')
    velocities = np.empty(len(segments), dtype=np.float64)
    def getVelocity(segment:ET.ElementTree):
        velocityProfile = getVelocityProfileOfSegment(layerTree, segment)
        return float(velocityProfile.find(".//Velocity").text)
    for i in range(len(segments)):
        velocities[i] = getVelocity(segments[i])

    return velocities

# generates an n by 2 numpy array listing each vertex in order of the print for the layer passed in
def generatePointList(layerTree:ET.ElementTree):
    trajectoryTree = layerTree.find('.//TrajectoryList')

    paths = trajectoryTree.findall('.//Path')
    segments = trajectoryTree.findall('.//Segment')

    # Paths add one point each, the start x/y, and segments add one point each, the end x/y
    # This lets us predetermine size of end array and avoid all uses of np.append
    points = np.empty((len(paths) + len(segments), 2), dtype=np.float64)
    i = 0

    # There is a separate start point for each path so the paths must be iterated through to pull it since its not labelled a segment
    # Not a convenient single loop here so we manually update the tqdm bar 
    for path in paths:

        startPoint = path.find('.//Start')
        startX = float(startPoint.find('.//X').text)
        startY = float(startPoint.find('.//Y').text)
        points[i] = [startX,startY]
        i += 1

        for segment in path.findall('.//Segment'):
            x = float(segment.find('.//X').text)
            y = float(segment.find('.//Y').text)
            points[i] = [x,y]
            i += 1

    return points

# generates an n by 2 list of edges where the entries are the index of the start and end points in the pointList (NOTE:kinda redundant? the point list is ordered)
def generateEdges(pointList:np.ndarray):
    edgeList = np.empty((len(pointList) - 1, 2), dtype=np.int32)
    for i in range(len(pointList) - 1):
        edgeList[i] = [i, i + 1]
    return edgeList

def generateTimeList(layerTree:ET.ElementTree):    
    trajectoryTree = layerTree.find('.//TrajectoryList')

    timeList = np.empty(1 + len(layerTree.findall('.//Segment')), dtype=np.float64)
    timeList[0] = 0;
    i = 1; 

    # There is a separate start point for each path so the paths must be iterated through to pull it since its not labelled as a segment
    # Not a convenient single loop here so we manually update the tqdm bar
    # TODO: Verify there isn't weird behavior from the last segment of a path to the first segment of another path
    paths = trajectoryTree.findall('.//Path')
    for path in paths:
        startPoint = path.find('.//Start')
        startX = float(startPoint.find('.//X').text)
        startY = float(startPoint.find('.//Y').text)

        for segment in path.findall('.//Segment'):
            endX = float(segment.find('.//X').text)
            endY = float(segment.find('.//Y').text)

            # this chunk finds the speed associated with the current end point
            velocityProfile = getVelocityProfileOfSegment(layerTree, segment)
            velocity = float(velocityProfile.find('.//Velocity').text)
            distance = math.sqrt(pow(endX-startX,2)+pow(endY-startY,2))
            
            time = distance/velocity
            if time < 0: 
                print("WARNING: Negative time detected. This is likely due to a negative velocity. Please check your velocity profile.")

            timeList[i] = time
            i += 1 

            # need to update the start point for the distance on the next iteration through loop
            startX = endX
            startY = endY

    return timeList

# Makes an HDF5 file for a layer from a layer file from a .scn file, the .scn must be unzipped and the individual layer file passed in
def convertLayerSCNtoHDF5(fileDirectory:str,root:h5py.File,layerNum:int):
    layerTree = ET.parse(fileDirectory)
    layerFolder = root.create_group(str(layerNum))

    layerFolder.create_dataset('/'+str(layerNum)+'/edgeData/power', data=generatePowerList(layerTree))
    velocityList = generateVelocityList(layerTree)    

    # TODO: Rest of these aren't fixed yet 
    layerFolder.create_dataset('/'+str(layerNum)+'/edgeData/velocity', data=velocityList)
    pointList = generatePointList(layerTree)
    layerFolder.create_dataset('/'+str(layerNum)+'/points', data=pointList)
    layerFolder.create_dataset('/'+str(layerNum)+'/edges',  data=generateEdges(pointList))
    layerFolder.create_dataset('/'+str(layerNum)+'/pointData/time', data=generateTimeList(layerTree))

    return layerFolder
    
# Converts a directory containing the unzipped layer files (.xml suffix) into an HDF5 file. directory must NOT have any other files in it
def convertSCNtoHDF5(inputDirectory:str, outputName:str):
    numLayers = len(os.listdir(inputDirectory + '/'))
    file=h5py.File(outputName,'w')

    for i in tqdm(range(numLayers), desc='Converting SCN to HDF5'):
        convertLayerSCNtoHDF5(inputDirectory + '/scan_' + str(i + 1) + '.xml',file, i)
    
    