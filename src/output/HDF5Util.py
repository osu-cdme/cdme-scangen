# This is a utility to allow the creation of HDF5 type files from scanpath data generated by the pyslm based slicer.

import numpy as np
import h5py
import xml.etree.ElementTree as ET
import math
import os

# TODO: Can probably make XPath searches quicker by being more specific than "search the entire tree for anything with this tag" 

#* Utility functions that occur frequently 
def getSegmentStyleOfSegment(layerTree:ET.ElementTree, segment:str):
    id = segment.find('.//SegStyle').text
    for segmentStyle in layerTree.findall(".//SegmentStyle"):
        if segmentStyle.find('.//ID').text == id:
            return segmentStyle
    raise ValueError('SegmentStyleID {} not found in SegmentStyleList'.format(id))

def getVelocityProfileOfSegment(layerTree:ET.ElementTree, segment:str):
    segmentStyle = getSegmentStyleOfSegment(layerTree, segment)
    velocityProfileID = segmentStyle.find('.//VelocityProfileID').text
    for velocityProfile in layerTree.findall('.//VelocityProfile'):
        if velocityProfile.find('.//ID').text == velocityProfileID:
            return velocityProfile
    raise ValueError('VelocityProfileID {} not found in VelocityProfileList'.format(velocityProfileID))

# Adds a layer to an existing HDF5 file.
def addHDF5Layer(HDF5FileName:str,layer:h5py.File):
    top=h5py.File(HDF5FileName,'r+')
    thisLayer=top.create_group(layer.name)

# generates an n by 1 numpy array listing the powers in order of each step in the print for the layer passed in
def generatePowerList(layerTree:ET.ElementTree):
    trajectoryTree = layerTree.find('.//TrajectoryList')
    if not trajectoryTree:
        raise ValueError('No TrajectoryList found in layerTree')
    segmentStyleTree = layerTree.find('.//SegmentStyleList')
    if not segmentStyleTree:
        raise ValueError('No SegmentStyleList found in layerTree')
    
    segments = trajectoryTree.findall('.//Segment')
    powers = np.empty(len(segments))
    def getPower(segment:ET.ElementTree):
        segmentStyle = getSegmentStyleOfSegment(layerTree, segment)
        if len(segmentStyle.findall('.//Traveler')):
            return int(segmentStyle.find('.//Power').text)
        return 0 # Jump
    for i in range(len(segments)):
        powers[i] = getPower(segments[i])

    return powers

# generate an n by 1 numpy array listing the velocities in order of each step in the print for the layer passed in
def generateVelocityList(layerTree:ET.ElementTree):
    velocityList = np.array([])
    trajectoryTree = layerTree.find('.//TrajectoryList')
    if not trajectoryTree:
        raise ValueError('No TrajectoryList found in layerTree')
    segmentStyleTree = layerTree.find('.//SegmentStyleList')
    if not segmentStyleTree:
        raise ValueError('No SegmentStyleList found in layerTree')
    VelocityProfileTree = layerTree.find('.//VelocityProfileList')
    if not VelocityProfileTree:
        raise ValueError('No VelocityProfileList found in layerTree')

    segments = trajectoryTree.findall('.//Segment')
    velocities = np.empty(len(segments))
    def getVelocity(segment:ET.ElementTree):
        velocityProfile = getVelocityProfileOfSegment(layerTree, segment)
        return float(velocityProfile.find(".//Velocity").text)
    for i in range(len(segments)): 
        velocities[i] = getVelocity(segments[i])

    return velocityList

# generates an n by 2 numpy array listing each vertex in order of the print for the layer passed in
def generatePointList(layerTree:ET.ElementTree):
    pointList = np.array([])
    trajectoryTree = layerTree.find('TrajectoryList')

    # There is a separate start point for each path so the paths must be iterated through to pull it since its not labelled a segment
    for path in trajectoryTree.findall("Path"):

        startPoint = path.find('Start')
        startX = startPoint.find('X')
        startY = startPoint.find('Y')

        pointList = np.append(pointList,[startX,startY])

        for segment in path.findall('Segment'):
            x = segment.find('X')
            y = segment.find('Y')

            pointList = np.append(pointList,[x,y])

    return pointList

# generates an n by 2 list of edges where the entries are the index of the start and end points in the pointList (NOTE:kinda redundant? the point list is ordered)
def generateEdges(pointList:np.ndarray):
    edgeList = np.array([])

    pointListLength = len(pointList)
    for i in range(pointListLength-1):
        edgeList = np.append(edgeList,[i,i+1])

    return edgeList

def generateTimeList(layerTree:ET.ElementTree):
    segmentStyleTree = layerTree.find('SegmentStyleList')
    VelocityProfileTree = layerTree.find('VelocityProfileList')
    timeList = np.array([])
    trajectoryTree = layerTree.find('TrajectoryList')

    timeList = np.append(timeList,0.0)

    # There is a separate start point for each path so the paths must be iterated through to pull it since its not labelled as a segment
    for path in trajectoryTree.findall("Path"):
        startPoint = path.find('Start')
        startX = startPoint.find('X')
        startY = startPoint.find('Y')

        for segment in path.findall('Segment'):
            endX = segment.find('X')
            endY = segment.find('Y')

            # this chunk finds the speed associated with the current end point
            associatedSegStyle = segmentStyleTree.find(segment.find('segStyle'))
            associatedVelocityProfile = VelocityProfileTree.find(associatedSegStyle.find('VelocityProfileID'))
            velocity = associatedVelocityProfile.find('Velocity')

            distance = math.sqrt(pow(endX-startX,2)+pow(endY-startY,2))

            time = distance/velocity

            timeList = np.append(timeList,time)

            # need to update the start point for the distance on the next iteration through loop
            startX = endX
            startY = endY

    return timeList

# Makes an HDF5 file for a layer from a layer file from a .scn file, the .scn must be unzipped and the individual layer file passed in
def convertLayerSCNtoHDF5(fileDirectory:str,root:h5py.File,layerNum:int):
    layerTree = ET.parse(fileDirectory)
    layerFolder = root.create_group(str(layerNum))

    layerFolder.create_dataset('/'+str(layerNum)+'/edgeData/power', data=generatePowerList(layerTree))
    velocityList = generateVelocityList(layerTree)    

    # TODO: Rest of these aren't fixed yet 
    layerFolder.create_dataset('/'+str(layerNum)+'/edgeData/velocity', data=velocityList)
    pointList = generatePointList(layerTree)
    layerFolder.create_dataset('/'+str(layerNum)+'/points', data=pointList)
    layerFolder.create_dataset('/'+str(layerNum)+'/edges',  data=generateEdges(pointList))
    layerFolder.create_dataset('/'+str(layerNum)+'/pointData/time', data=generateTimeList(layerTree))

    return layerFolder
    
# Converts a directory containing the unzipped layer files (.xml suffix) into an HDF5 file. directory must NOT have any other files in it
def convertSCNtoHDF5(inputDirectory:str, outputName:str):
    numLayers = len(os.listdir(inputDirectory + '/'))
    file=h5py.File(outputName,'w')

    for i in range(numLayers):
        convertLayerSCNtoHDF5(inputDirectory + '/scan_' + str(i + 1) + '.xml',file, i)
    
    